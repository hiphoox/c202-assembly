defmodule Error.ErrorDetecter do
   @moduledoc """
    Show errors generated by the output of `Lexer.tokenize / 1` and` Parser.parse / 2` module methods.
    """

    @doc """
    ## Specs
      ```token``` fault token identified in the `Lexer` output.
      ```file_path``` is the path to the file to be compiled.
      ```raw_source_code_string``` contains the source code string without any special characters removals like newline or tabs.
  """
  def lexer_error(token, file_path, raw_source_code_string)   do
    {row, col} = Error.RowColDetecter.find_row_col(token, raw_source_code_string)
    class_msg =         "** (Lexer Error) invalid token"
    fault_element_msg = "#{token.expression}"
    reason_msg  =       ""
    location_msg =      "#{file_path}"
    row_col_msg =       ":#{row}:#{col}"
    IO.Printer._print_error(
      class_msg, fault_element_msg, reason_msg, location_msg, row_col_msg
    )
  end

  @doc """
  ## Specs
    ```status_atom``` atom that indicates the type of invalid action generated by the `Parser` output.
    ```tl``` token list of all the bad tokens found in the source code.
    ```error_cause``` `Node` that contains the node causing the source code compilation failure.
    ```expected_structure``` `Node` that contains the expected node the source code needs to compile.
    ```file_path``` is the path to the file to be compiled.
    ```position_tuple``` tuple containing the row and col of the fault token.
  """
  def parser_error(:token_missing_error, tl, error_cause, expected_structure, file_path, 
    position_tuple)  do
    class_msg =         "** (Parser Error) structure"
    fault_element =     error_cause.tag
    found_token = Enum.at(tl, 0)
    if found_token == nil do
      reason_msg =        " expected " <> expected_structure.tag <> " but found nothing"
      location =          file_path
      row_col_msg =       ""
      IO.Printer._print_error(
        class_msg, fault_element, reason_msg, location, row_col_msg
      )
    else
      {col, row} = position_tuple
      reason_msg =        " expected " <> expected_structure.tag <> " but found " <> found_token.expression
      location =          file_path
      row_col_msg =       "#{row}:#{col}"
      IO.Printer._print_error(
        class_msg, fault_element, reason_msg, location, row_col_msg
      )
    end
    
  end
  def parser_error(:token_not_absorbed_error, tl, _, _ ,file_path,
    position_tuple)      do
    {col, row} = position_tuple
    class_msg =     "** (Parser Error) token"
    fault_element = Enum.at(tl, 0).expression
    reason_msg =    "was not accepted"
    location =      file_path
    row_col_msg =       "#{row}:#{col}"
    IO.Printer._print_error(
      class_msg, fault_element, reason_msg, location, row_col_msg
    )
  end
end
